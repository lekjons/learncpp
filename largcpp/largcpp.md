
# 大规模C++程序编写基本规则

- 设计规则必须足够准确、详尽和良好定义，以便可以客观的检验是否遵守了这些规则  
- 设计规则必须适合非人为的、借助自动工具的机械验证  

    **设计规则分类**  
    主要：必须一直遵守的规则  
    次要：强烈推荐但对于一个项目的整体成功不是比不可少的关键因素  

## 1 成员的数据访问

> 主要设计规则  
**保持类数据成员的私有性**
> 封装：若不能通过某个类的逻辑接口编程访问或检测到其包含的实现细节，则称这些实现细节被该类封装了
> 提供类操纵函数和访问函数也赋予了开发者插入临时代码的机会（例如：为了调试的打印语句，为了性能调整的参考计数，为了可靠性的assert语句）
> 对自身整个被隐藏的结构（类）的数据成员的公共访问是不同的，不使用上述规则。
> 当数据成员并非私有时，通过使用***struct***  而不是 ***class*** 来表示认为不需要封装的结构更合适

## 2 全局名称空间

### 2.1 全局数据

- 使用全局变量的特殊情况  

    (1) 通过全局变量进行通讯的结构复杂的程序访问  

    (2) 嵌入式系统中的访问  

- 主要设计规则  
**避免在文件作用域内包含带为不连接的数据**  

- 避免变量全局化的方法  

    (1) 将所有全局变量放入一个结构中

    (2) 然后将他们私有化并添加静态访问函数  

```C++全局变量
int size;
double scale;
const char *system;
///////转化(不是最好的方法)////////
struct Global
{
    static int s_size;
    static double s_scale;
    static const char *s_system;
}
inadvertent instantiation
```

***使用模型：*** 建立一个类，提供静态的操纵和访问静态变量的方法，不需要实例化该类，将默认构造函数声明为私有强化该模型。

### 2.2 自由函数

> **主要设计规则**  
在.h文件的文件作用域内避免使用自由函数（运算符函数除外）;在.c文件中避免使用带有外部连接的自由函数（包括运算符函数）。
> 避免自由函数的方法
将自由函数变为静态函数封装在某个类中

### 2.3 枚举类型、typedef和常量数据

***习惯性错误***：人们经常在头文件的文件作用域内声明常量、枚举类型或用户自定义类型,***可以在一个类的作用域中定义枚举类型（或声明typedef）***。

> **主要设计规则**  
在.h文件作用域内避免使用枚举类型、typedef和常量数据  

***封装在.h文件类中的静态数据成员要在.c文件中初始化***

### 2.4 预处理器宏

- **主要设计规则**  
在头文件中避免使用预处理宏，除非作为包含***guards***

### 2.5 头文件中的名称

> **主要设计规则**  
只有类、结构、联合和自由运算符函数应该在.h文件的文件作用域内声明;只有类、结构、联合和内联函数（成员或自由运算符）应该在.h文件的文件作用域内定义。

## 3 包含guards

> **主要设计规则**  
在每个头文件的内容周围放置一个唯一的和可预知的（内部）包含guards  

```C++ guards
// stack.h
 #ifndef INCLUDED_STACK
 #define INCLUDED_STACK
 // ...
#endif
```

## 4 冗余包含guards

> **次要设计规则**  
在每个头文件预处理器的包含指令周围，放置一个冗余（外部）包含guards。

